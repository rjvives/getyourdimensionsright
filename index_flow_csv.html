<script>
  /********* CONFIG *********/
  // Si tu CSV está en otra carpeta, ajusta la ruta:
  const CSV_URL = 'flow_rivers.csv?v=20250826'; // cambia el número cuando actualices el CSV

  /********* UTILIDADES *********/
  const fmt = (n) => new Intl.NumberFormat(undefined, { maximumFractionDigits: 0 }).format(n);
  function niceStep(x){ if(x<=0) return 1; const k=Math.floor(Math.log10(x)); const b=x/10**k; const m=b<=1?1:b<=2?2:b<=5?5:10; return m*10**k; }

  // Detectar delimitador (",", ";" o tab) usando la cabecera
  function detectDelimiter(headerLine){
    const candidates = [',',';','\t'];
    let best = ',', bestCount = 0;
    for(const d of candidates){
      const count = headerLine.split(d).length - 1;
      if(count > bestCount){ bestCount = count; best = d; }
    }
    return best;
  }

  // Parser robusto: BOM, comillas, \r\n, delimitador variable
  function parseCSV(text){
    if (!text) return [];
    // Quitar BOM
    if (text.charCodeAt(0) === 0xFEFF) text = text.slice(1);

    // Tomar primera línea para detectar delimitador
    const firstNL = text.indexOf('\n');
    const firstLine = firstNL >= 0 ? text.slice(0, firstNL) : text;
    const DELIM = detectDelimiter(firstLine);

    const rows = [];
    let cur = [], field = '', inQuotes = false;
    for (let i = 0; i < text.length; i++) {
      const c = text[i];
      if (c === '"') {
        if (inQuotes && text[i+1] === '"') { field += '"'; i++; }
        else inQuotes = !inQuotes;
      } else if (c === DELIM && !inQuotes) {
        cur.push(field); field = '';
      } else if ((c === '\n' || c === '\r') && !inQuotes) {
        if (c === '\r' && text[i+1] === '\n') i++;
        cur.push(field); rows.push(cur); cur = []; field = '';
      } else {
        field += c;
      }
    }
    if (field !== '' || cur.length) { cur.push(field); rows.push(cur); }

    if (!rows.length) return [];
    const headers = rows.shift().map(h => (h ?? '').trim());
    return rows
      .filter(r => r.length && r.some(x => x && String(x).trim() !== ''))
      .map(r => {
        const obj = {};
        headers.forEach((h, idx) => obj[h] = ((r[idx] ?? '') + '').trim());
        return obj;
      });
  }

  /********* ESTADO *********/
  let DB = { byScale: new Map(), scales: [] };

  /********* CARGA CSV *********/
  async function loadCSV(){
    // Aviso si se abre local (file://) — fetch suele fallar
    if (location.protocol === 'file:') {
      throw new Error('Este archivo se abrió con file:// — usa un servidor local (p.ej., python -m http.server) o publícalo en GitHub Pages.');
    }

    const res = await fetch(CSV_URL, { cache: 'no-store' });
    if (!res.ok) {
      throw new Error(`No se pudo cargar ${CSV_URL} (HTTP ${res.status})`);
    }
    const txt = await res.text();

    const rows = parseCSV(txt);
    if (!rows.length) {
      throw new Error('El CSV se cargó pero no se detectaron filas. Revisa delimitador, encabezados y líneas.');
    }

    // Validar encabezados requeridos
    const required = ['Scale','Name','Value','Value range','Description'];
    const missing = required.filter(h => !(h in rows[0]));
    if (missing.length) {
      throw new Error(`Faltan encabezados en el CSV: ${missing.join(', ')}`);
    }

    const byScale = new Map();
    for (const row of rows){
      const scale = row['Scale'];
      const name = row['Name'];
      const value = parseFloat(row['Value']);
      const rangeStr = row['Value range'];
      const desc = row['Description'];
      if(!scale || !name || !rangeStr) continue;
      const m = rangeStr.match(/^(\d+(?:[\.,]\d+)?)\s*-\s*(\d+(?:[\.,]\d+)?)/);
      if(!m) continue;
      const rmin = parseFloat(String(m[1]).replace(',','.'));
      const rmax = parseFloat(String(m[2]).replace(',','.'));
      const item = { scale, name, value, rmin, rmax, desc };
      if(!byScale.has(scale)) byScale.set(scale, []);
      byScale.get(scale).push(item);
    }

    for (const [scale, arr] of byScale){
      arr.sort((a,b)=> a.rmin - b.rmin);
      arr.forEach((it, i)=> it.slot = i+1);
    }

    DB.byScale = byScale;
    DB.scales = Array.from(byScale.keys());

    // Logs de depuración (abre la consola)
    console.log('CSV cargado:', { escalas: DB.scales, ejemplo: rows.slice(0,3) });
  }

  /********* UI *********/
  function populateZooms(){
    const zSel = document.getElementById('zoomSelect');
    zSel.innerHTML = '';
    for(const z of DB.scales){
      const opt = document.createElement('option');
      opt.value = z; opt.textContent = z;
      zSel.appendChild(opt);
    }
  }

  function setSliderToScale(scale){
    const items = DB.byScale.get(scale) || [];
    const mins = items.map(x=>x.rmin);
    const maxs = items.map(x=>x.rmax);
    if(!mins.length || !maxs.length){ return; }
    const min = Math.min(...mins);
    const max = Math.max(...maxs);
    const slider = document.getElementById('valueSlider');
    const step = niceStep((max-min)/200);
    slider.min = min; slider.max = max; slider.step = step;
    if(parseFloat(slider.value) < min || parseFloat(slider.value) > max){
      slider.value = min;
    }
    document.getElementById('rangeReadout').textContent = `Rango del zoom → ${fmt(min)} – ${fmt(max)} m³/s (step ${fmt(step)})`;
    document.getElementById('valueReadout').textContent = fmt(parseFloat(slider.value));
  }

  function findMatch(scale, value){
    const items = DB.byScale.get(scale) || [];
    let match = items.find(x => value >= x.rmin && value <= x.rmax);
    if(match) return match;
    // si no cae justo, elegir el rango más cercano por distancia al centro
    let best=null, bestDist=Infinity;
    for(const it of items){
      const center = 0.5*(it.rmin+it.rmax);
      const d = Math.abs(value-center);
      if(d < bestDist){ best=it; bestDist=d; }
    }
    return best;
  }

  function render(){
    const scale = document.getElementById('zoomSelect').value;
    const val = parseFloat(document.getElementById('valueSlider').value);
    const m = findMatch(scale, val);
    const box = document.getElementById('resultBox');
    if(!m){
      box.innerHTML = '<span class="small muted">Sin datos para este zoom.</span>';
      document.getElementById('resultHeading').textContent = `Zoom: ${scale || '—'} · Caudal: ${isFinite(val)? fmt(val): '—'} m³/s`;
      return;
    }
    box.innerHTML = `
      <div class="river-card">
        <div class="river-thumb"> <span class="small muted">(imagen opcional)</span> </div>
        <div>
          <div><b>${m.name}</b> <span class="small muted">· Slot ${m.slot ?? '?'} / ${DB.byScale.get(scale)?.length || '?'}</span></div>
          <div class="small muted">Rango: ${fmt(m.rmin)} – ${fmt(m.rmax)} m³/s · Valor ref: ${isFinite(m.value)? fmt(m.value): '—'} m³/s</div>
          <div style="margin-top:6px;">${m.desc || ''}</div>
        </div>
      </div>`;
    document.getElementById('resultHeading').textContent = `Zoom: ${scale} · Caudal: ${fmt(val)} m³/s`;
  }

  // Eventos
  document.getElementById('zoomSelect').addEventListener('change', ()=>{
    setSliderToScale(zoomSelect.value);
    render();
  });
  document.getElementById('valueSlider').addEventListener('input', ()=>{
    document.getElementById('valueReadout').textContent = fmt(parseFloat(valueSlider.value));
    render();
  });

  // Init
  (async function init(){
    try{
      await loadCSV();
      populateZooms();
      if(DB.scales.length){
        document.getElementById('zoomSelect').value = DB.scales[0];
        setSliderToScale(DB.scales[0]);
      } else {
        document.getElementById('resultBox').innerHTML = '<span class="small muted">CSV cargado pero no hay escalas. ¿Encabezados correctos? ¿Delimitador correcto?</span>';
      }
      render();

      // Test rápido en consola
      fetch(CSV_URL, { cache: 'no-store' }).then(r=>r.text()).then(t=>{
        const preview = t.split('\n').slice(0,5).join('\n');
        console.log('Preview CSV (primeras líneas):\n' + preview);
      }).catch(e=>console.warn('No se pudo leer preview del CSV:', e));

    }catch(e){
      document.getElementById('resultBox').innerHTML = `<span class="small muted">${e.message}</span>`;
      console.error(e);
    }
  })();
</script>
